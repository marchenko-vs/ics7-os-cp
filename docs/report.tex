\documentclass{bmstu}

\usepackage{biblatex}
\usepackage{array}
\usepackage{amsmath}

\addbibresource{inc/biblio/sources.bib}

\begin{document}

\makecourseworktitle
    {Информатика и системы управления}
    {Программное обеспечение ЭВМ и информационные технологии}
    {Загружаемый модуль ядра для мониторинга сетевого трафика процесса}
    {В.~Марченко/ИУ7-73Б}
    {Н.~Ю.~Рязанова}
    {}

\setcounter{page}{3}

{\centering \chapter*{РЕФЕРАТ}}

Расчетно-пояснительная записка 41 с., 15 рис., 0 табл., 6 источн., 2 прил.

\noindent ЗАГРУЖАЕМЫЙ МОДУЛЬ ЯДРА, ОПЕРАЦИОННЫЕ СИСТЕМЫ, СЕТЕВОЙ ТРАФИК, СИСТЕМНЫЕ ВЫЗОВЫ, СОКЕТЫ, ФУНКЦИИ ЯДРА, FTRACE, LINUX

Объектом разработки является загружаемый модуль ядра для мониторинга сетевого трафика процесса.

Цель работы: реализация загружаемого модуля ядра, с помощью которого можно получить суммарный размер полученных и отправленных каким-либо процессом пакетов по сети.

В результате выполнения работы был реализован и протестирован загружаемый модуль ядра для мониторинга сетевого трафика процесса.

Область применения результатов --- отслеживание сетевого трафика процесса и увеличение функционала реализованного загружаемого модуля ядра.

{\centering \maketableofcontents}

{\centering \chapter*{ПЕРЕЧЕНЬ СОКРАЩЕНИЙ И ОБОЗНАЧЕНИЙ}}

В настоящей расчетно-пояснительной записке к курсовой работе применяют следующие сокращения и обозначения:

\begin{table}[H]
\begin{tabular}{p{5cm}p{10.5cm}}
ОС & Операционная система
\tabularnewline
ПО & Программное обеспечение
\tabularnewline
ЗМЯ & Загружаемый модуль ядра
\tabularnewline
PID & Идентификатор процесса (от англ. process identifier)
\tabularnewline
\end{tabular}
\end{table}

{\centering \chapter*{ВВЕДЕНИЕ}}
\addcontentsline{toc}{chapter}{ВВЕДЕНИЕ}

Сетевой трафик --- объем информации, передаваемой через компьютерную сеть за определенный период времени. 
Количество трафика измеряется как в пакетах, так и в битах, байтах и их производных. 
Трафик подразделяется на:
\begin{enumerate}
\item[1)] исходящий (информация, поступающая во внешнюю сеть);
\item[2)] входящий (информация, поступающая из внешней сети);
\item[3)] внутренний (в пределах определенной сети, чаще всего локальной);
\item[4)] внешний (за пределами определенной сети).
\end{enumerate}

В настоящее время сетевой трафик является неотъемлемой частью повседневной жизни, и его отслеживание играет важную роль в различных сферах. Отслеживание сетевого трафика позволяет анализировать передаваемые данные, идентифицировать нарушения безопасности, оптимизировать сеть и повышать эффективность работы.

Существует множество программ для подсчета сетевого трафика. 
Например, TMeter, BWMeter, BitMeter II и GabNetStats --- это утилиты для операционных систем семейства Microsoft Windows. 
Для Linux доступны программы vnStat, Nload и slurm. 
На рисунке~\ref{img:vnstat} показан пример работы утилиты vnStat.
Вышеперечисленные программы позволяют получать информацию о скорости передачи данных в сети и об объеме передаваемых по сети пакетов. 
Существенный недостаток некоторых из этих инструментов --- они отслеживают сетевой трафик не для конкретного процесса, а для всей системы.

Для отслеживания сетевого трафика необходимо перехватывать функции ядра. 
Существует несколько способов это сделать:
\begin{enumerate}
\item[1)] использование модулей безопасности Linux (Linux Security Modules);
\item[2)] модификация таблицы системных вызовов (данный способ устарел для новых версий ядра);
\item[3)] использование kprobe;
\item[4)] использование утилиты strace;
\item[5)] использование системного вызова ptrace();
\item[6)] использование фреймворка ftrace.
\end{enumerate}

\includeimage
    {vnstat}
    {f}
    {H}
    {1\textwidth}
    {Пример работы утилиты vnStat}

\chapter{Аналитическая часть}

\section{Постановка задачи}

Целью курсовой работы является реализация загружаемого модуля ядра, с помощью которого можно получить суммарный размер полученных и отправленных каким-либо процессом пакетов по сети.

Задачи курсовой работы:
\begin{enumerate}
\item[1)] провести обзор существующих средств для перехвата функций ядра Linux;
\item[2)] спроектировать загружаемый модуль ядра для мониторинга сетевого трафика процесса;
\item[3)] реализовать загружаемый модуль ядра для мониторинга сетевого трафика процесса;
\item[4)] протестировать реализованное программное обеспечение.
\end{enumerate}

Нужно реализовать загружаемый модуль ядра, который будет перехватывать функции, относящиеся к передачи пакетов по сети. 
Кроме того, подсчет объема сетевого трафика должен вестись для конкретного процесса, поэтому перед загрузкой модуля, ему на вход нужно передать имя файла. 
Для хранения объема отправленных и полученных пакетов в байтах можно использовать переменную типа uint64\_t. 
Этот тип данных обеспечивает наибольший диапазон беззнаковых чисел в языке C. 
Таким образом, ограничение к разрабатываемому модулю: наибольший объем полученных или отправленных по сети пакетов --- 16384 пебибайт (18446744074 гигабайт).

\section{Способы перехвата функций ядра Linux}

\subsection{strace}

В Linux есть несколько средств для перехвата функций ядра. 
Первое средство --- утилита strace.

strace --- это диагностическая и отладочная утилита, работающая в пространстве пользователя. 
Она используется для мониторинга и изменения взаимодействия между процессами и ядром Linux, включая системные вызовы, доставку сигналов и изменения состояния процесса. 
Данная утилита подходит для решения проблем с программами, исходный код которых недоступен, поскольку их не нужно перекомпилировать для отладки. 
Работа strace основана на системном вызове ptrace()~\cite{Strace}.

Достоинства strace --- утилиту можно запустить для трассировки уже работающий программы; можно фильтровать системные вызовы, которые необходимо отслеживать, по типу; а также можно собирать статистику (количество вызовов, время выполнения и ошибки)~\cite{Strace}.

В листинге~\ref{lst:strace.sh} показан пример работы утилиты strace.

\includelisting{strace.sh}{Пример работы утилиты strace}

Однако strace, во-первых, работает в пространстве пользователя, во-вторых, является утилитой, поэтому это средство не может быть использовано в данной курсовой работе.

\subsection{ptrace}

ptrace (от англ. process trace) --- системный вызов в некоторых UNIX-подобных системах (в том числе в Linux и FreeBSD), который позволяет трассировать или отлаживать выбранный процесс. 
Можно сказать, что ptrace дает полный контроль над процессом: можно изменять ход выполнения программы, смотреть и изменять значения в памяти или состояния регистров. 
Никаких дополнительных прав нет --- возможные действия ограничены правами запущенного процесса. 
К тому же, при трассировке программы с setuid битом, этот самый бит не работает --- привилегии не повышаются~\cite{Ptrace}.

В листинге~\ref{lst:ptrace.h} показан прототип системного вызова ptrace().

\includelisting{ptrace.h}{Прототип системного вызова ptrace()}

Значения параметров системного вызова ptrace(): request --- это действие, которое необходимо осуществить, например PTRACE\_CONT, PTRACE\_PEEKTEXT, pid --- идентификатор трассируемого процесса, addr и data зависят от request~\cite{Ptrace}.

Начать трассировку можно двумя способами: для уже запущенного процесса (PTRACE\_ATTACH), либо запустить процесс самому с помощью PTRACE\_TRACEME. 
Для управления трассировкой можно использовать следующие аргументы~\cite{Ptrace}:
\begin{enumerate}
\item[1)] PTRACE\_SINGLESTEP --- пошаговое выполнение программы, управление будет передаваться после выполнения каждой инструкции (такая трассировка достаточно медленная);
\item[2)] PTRACE\_SYSCALL --- продолжить выполнение программы до входа или выхода из системного вызова;
\item[3)] PTRACE\_CONT --- продолжить выполнение программы.
\end{enumerate}

Как и strace, ptrace работает в пространстве пользователя, поэтому для использования в курсовой работе данное средство не подходит.

\subsection{ftrace}

ftrace --- это внутренний трассировщик, призванный помочь разработчикам и проектировщикам систем обнаружить, что происходит внутри ядра. 
Его можно использовать для отладки или анализа задержек и проблем с производительностью, возникающих за пределами пространства пользователя~\cite{Ftrace}.

Хотя ftrace обычно считается средством трассировки функций, на самом деле это совокупность нескольких различных утилит трассировки. 
Существует трассировка задержки для проверки того, что происходит между отключенными и включенными прерываниями, а также с момента пробуждения задачи до ее фактического планирования~\cite{Ftrace}.

Одним из наиболее распространенных применений ftrace является трассировка событий. 
По всему ядру есть сотни статических событий, которые можно включить через файловую систему tracefs, чтобы увидеть, что происходит в определенных частях ядра~\cite{Ftrace}.

Инфраструктура ftrace изначально была создана для прикрепления функций обратного вызова (callbacks) к началу функций с целью записи и отслеживания потока ядра. 
Но обратные вызовы в начале функции могут иметь и другие варианты использования. 
Либо для оперативного исправления ядра, либо для мониторинга безопасности~\cite{Ftrace}.

Чтобы зарегистрировать функции обратного вызова, нужно использовать структуру struct ftrace\_ops. 
Эта структура используется, чтобы сообщить ftrace, какую функцию следует вызывать в качестве обратного вызова~\cite{Ftrace}.

Необходимо заполнить только одно поле при регистрации struct ftrace\_ops --- func. 
Поля flags и private не являются обязательными~\cite{Ftrace}. 
В листинге~\ref{lst:ftrace_ops.c} показан пример заполнения полей структуры struct ftrace\_ops.

\includelisting{ftrace_ops.c}{Пример заполнения полей структуры struct ftrace\_ops}

Чтобы начать трассировку, нужно вызвать функцию register\_ftrace\_function(\&fops), а чтобы завершить --- unregister\_ftrace\_function(\&fops)~\cite{Ftrace}.

Структура struct ftrace\_ops и необходимые для трассировки функции определены в заголовочном файле <linux/ftrace.h>~\cite{Ftrace}.

ftrace работает в пространстве ядра, а также позволяет перехватывать функции ядра, поэтому данное средство может быть использовано в курсовой работе.

\section{Аргументы командной строки для загружаемого модуля ядра}

Как и любая другая программа на языке C, загружаемый модуль ядра может принимать аргументы командной строки. 
Чтобы разрешить передачу аргументов в модуль, нужно объявить переменные, которые будут принимать значения аргументов командной строки, как глобальные, а затем использовать макрос module\_param(), который определен в <linux/moduleparam.h>. 
Во время выполнения insmod проинициализирует переменные значениями аргументов командной строки. 
Для ясности объявления переменных и макросы следует размещать в начале модуля. 
Макрос module\_param() принимает 3 аргумента: имя переменной, ее тип и права доступа к соответствующему файлу в sysfs. 
Если необходимо использовать массивы целых чисел или строк, нужно использовать макросы module\_param\_array() и module\_param\_string()~\cite{ArgvLkm}.

В листинге~\ref{lst:argv.c} показан пример объявления глобальных переменных, которые могут быть проинициализированы с помощью аргументов командной строки.

\includelisting{argv.c}{Пример объявления глобальных переменных для использования аргументов командной строки}

\section{Функции ядра, которые нужно перехватывать}

Прототипы функций ядра, которые могут быть перехвачены с помощью ftrace, находятся в заголовочном файле <syscalls.h>~\cite{Syscalls}.

Чтобы определить функции ядра, которые выполняются при вызове каких-либо конкретных системных вызовов, можно написать небольшую программу и воспользоваться рассмотренной ранее утилитой strace.

Для того, чтобы отслеживать конкретный процесс, после передачи имени файла на вход загружаемому модулю ядра, нужно запустить этот файл. 
Необходимо перехватить функцию sys\_execve(), которая вызывается при запуске программы. 
Затем с помощью функции copy\_from\_user() модуль сможет получить название запущенной программы и сравнить с тем, который был передан в качестве аргумента командной строки. 
Вторая функция ядра --- sys\_exit\_group() --- будет вызвана при завершении отслеживаемого процесса. 
Перехватив эту функцию, загружаемый модуль ядра запишет в системный лог статистику.

Также нужно перехватывать функции ядра, которые вызываются в системных вызовах, связанных с передачей пакетов по сети. 
Это следующие функции ядра: sys\_send(), sys\_sendto(), sys\_sendmsg(), sys\_recv(), sys\_recvfrom() и sys\_recvmsg().

В листинге~\ref{lst:syscalls.h} показаны прототипы перечисленных выше функций ядра~\cite{Syscalls}.

\includelisting{syscalls.h}{Прототипы функций ядра, которые нужно перехватывать для мониторинга сетевого трафика процесса}

\section*{Вывод из аналитической части}

В ходе выполнения аналитической части курсовой работы были сформулированы требования к загружаемому модуля ядра, рассмотрены инструменты для перехвата функций ядра Linux, выбран подходящий инструмент, а также определены функции ядра, которые необходимо перехватывать для реализации загружаемого модуля ядра.

\chapter{Конструкторская часть}

\section{Используемые структуры}

Помимо упомянутой в аналитической части структуры struct ftrace\_ops для работы с ftrace, были разработаны две другие структуры, необходимые для реализации загружаемого модуля ядра. 
Первая --- struct hook, показанная в листинге~\ref{lst:hook.c}. 
Поле name содержит название функции ядра (например, sys\_send). 
Поле function --- указатель на функцию, которую нужно вызвать вместо исходной. 
Поле original указывает на исходную функцию ядра. 
Поле address --- адрес исходной функции ядра. 
А поле ops --- экземпляр структуры struct ftrace\_ops.

\includelisting{hook.c}{Структура struct hook}

Вторая структура, показанная в листинге~\ref{lst:net_traffic.c}, имеет всего три поля. 
Поле pid содержит идентификатор отслеживаемого процесса. 
Изначально значение этого поля равно -1. 
После того, как нужная программа будет запущена, поле pid проинициализируется идентификатором отслеживаемого процесса. 
Поля bytes\_received и bytes\_sent хранят объем соответственно входящих и исходящих пакетов в байтах.

\includelisting{net_traffic.c}{Структура struct net\_traffic}

\section{Описание последовательности выполняемых ПО действий}

На рисунках~\ref{img:idef0-a0}--\ref{img:idef0-a1} показана последовательность выполняемых программным обеспечением действий в виде IDEF0-диаграмм нулевого и первого уровней.

\includeimage
    {idef0-a0}
    {f}
    {H}
    {.75\textwidth}
    {IDEF0-диаграмма нулевого уровня}
    
\includeimage
    {idef0-a1}
    {f}
    {H}
    {1\textwidth}
    {IDEF0-диаграмма первого уровня}

\pagebreak 
\section{Описание загрузки модуля ядра}

На рисунке~\ref{img:init-module} показана схема алгоритма загрузки модуля ядра. 
Сначала проверяется, было ли указано имя файла в качестве аргумента командной строки при загрузке модуля. 
Затем, если проверка прошла успешно, устанавливаются хуки на функции ядра, описанные в аналитической части, и модуль загружается.

\includeimage
    {init-module}
    {f}
    {H}
    {.75\textwidth}
    {Схема алгоритма загрузки модуля ядра}

\pagebreak 
\section{Описание поиска нужного процесса}

На рисунке~\ref{img:execve} показана схема алгоритма поиска того процесса, чей сетевой трафик должен мониторить загружаемый модуль ядра.

\includeimage
    {execve}
    {f}
    {H}
    {1\textwidth}
    {Схема алгоритма поиска нужного процесса}

\section{Описание получения размера пакета}

На рисунке~\ref{img:hook-send} показана схема алгоритма получения размера отправленного пакета на примере функции ядра sys\_send().

\includeimage
    {hook-send}
    {f}
    {H}
    {.75\textwidth}
    {Схема алгоритма получения размера пакета}

\section*{Вывод из конструкторской части}

В ходе выполнения конструкторской части курсовой работы были приведены используемые структуры, описана в виде IDEF0-диаграмм последовательность выполняемых программным обеспечением действий, а также описаны в виде схем алгоритмов загрузка модуля ядра, поиск нужного процесса и получение размера пакета.

\chapter{Технологическая часть}

\section{Выбор языка и среды программирования}

Для реализации программного обеспечения был выбран язык программирования C, так как на нем написано ядро Linux, и он используется для написания загружаемых модулей ядра.

Во время написания аналитической части курсовой работы был выбран фреймворк ftrace для трассировки ядра Linux. 
Именно он и используется для перехвата нужных функций ядра.

Для написания кода был выбран текстовый редактор Sublime Text 3, т.~к. он обладает следующими преимуществами~\cite{SublimeText}:
\begin{enumerate}
\item[1)] кроссплатформенность (доступность на Linux Ubuntu);
\item[2)] подсветка синтаксиса (в частности, для языка C);
\item[3)] настраиваемый интерфейс;
\item[4)] множественное выделение (например, переменных);
\item[5)] автоматическое заполнение.
\end{enumerate}

\section{Реализация функции загрузки модуля ядра}

В листинге~\ref{lst:init-module.c} показана реализация функции загрузки модуля ядра с проверкой аргумента командной строки.

\includelisting{init-module.c}{Реализация функции загрузки модуля ядра}

\section{Реализация функции поиска нужного процесса}

В листинге~\ref{lst:sys-execve.c} показана реализация функции поиска процесса, чей сетевой трафик должен отслеживать загружаемый модуль ядра.

\includelisting{sys-execve.c}{Реализация функции поиска нужного процесса}

\section{Реализация функции получения размера пакета}

В листинге~\ref{lst:sys-send.c} показана реализация функции получения размера отправленного пакета на примере перехвата функции ядра sys\_send().

\includelisting{sys-send.c}{Реализация функции получения размера пакета}

\section{Реализация функции установки хука}

В листинге~\ref{lst:install-hook.c} показана реализация функции установки хука для перехвата функций ядра.

\includelisting{install-hook.c}{Реализация функции установки хука}

\section{Makefile для сборки загружаемого модуля ядра}

В листинге~\ref{lst:makefile} показан Makefile для сборки загружаемого модуля ядра.

\includelisting{makefile}{Makefile для сборки загружаемого модуля ядра}

\section*{Вывод из технологической части}

В ходе выполнения технологической части курсовой работы были выбраны средства реализации программного обеспечения и среда разработки, а также написан исходный код загружаемого модуля ядра для мониторинга сетевого трафика процесса.

\chapter{Исследовательская часть}

\section{Технические характеристики устройства}

Технические характеристики устройства, на котором было проведено тестирование реализованного программного обеспечения:
\begin{enumerate}
\item[1)]
операционная система Ubuntu 22.04.3 LTS;
\item[2)]
оперативная память 4 ГБ;
\item[3)]
процессор Intel\textregistered ~Core\texttrademark ~i5-4790K @ 4.00 ГГц;
\item[4)] версия ядра Linux 6.2.0.
\end{enumerate}

\section{Тестирование программного обеспечения}

Для тестирования реализованного загружаемого модуля ядра для мониторинга сетевого трафика процесса были написаны две тестовые программы. 
Обе используют архитектуру <<клиент---сервер>>. 
В первой программе для взаимодействия используются системные вызовы recv() и send(), а во второй --- recvfrom() и sendto().
Также загружаемый модуль ядра был протестирован с помощью браузера Mozilla Firefox.

На рисунке~\ref{img:ui-01} показан результат работы загружаемого модуля ядра при отсутствии аргумента командной строки.

\includeimage
    {ui-01}
    {f}
    {H}
    {1\textwidth}
    {Результат работы загружаемого модуля ядра при отсутствии аргумента командной строки}
 
На рисунке~\ref{img:ui-02} показан результат работы загружаемого модуля ядра, который мониторил сетевой трафик процесса-сервера, использующего системные вызовы recv() и send(). 
На рисунках~\ref{img:client-02}--\ref{img:server-02} показаны размеры пакетов, которые соответственно получал и отправлял отслеживаемый процесс.

\includeimage
    {client-02}
    {f}
    {H}
    {1\textwidth}
    {Размеры пакетов, которые получал отслеживаемый процесс}
    
\includeimage
    {server-02}
    {f}
    {H}
    {1\textwidth}
    {Размеры пакетов, которые отправлял отслеживаемый процесс}

\includeimage
    {ui-02}
    {f}
    {H}
    {1\textwidth}
    {Результат работы загружаемого модуля ядра на примере системных вызовов recv() и send()}
    
На рисунке~\ref{img:ui-03} показан результат работы загружаемого модуля ядра, который мониторил сетевой трафик процесса-сервера, использующего системные вызовы recvfrom() и sendto(). 
На рисунках~\ref{img:client-03}--\ref{img:server-03} показаны размеры пакетов, которые соответственно получал и отправлял отслеживаемый процесс.

\includeimage
    {client-03}
    {f}
    {H}
    {1\textwidth}
    {Размеры пакетов, которые получал отслеживаемый процесс}
    
\includeimage
    {server-03}
    {f}
    {H}
    {1\textwidth}
    {Размеры пакетов, которые отправлял отслеживаемый процесс}

\includeimage
    {ui-03}
    {f}
    {H}
    {1\textwidth}
    {Результат работы загружаемого модуля ядра на примере системных вызовов recvfrom() и sendto()}
    
На рисунках~\ref{img:ui-04}--\ref{img:ui-05} показан результат работы загружаемого модуля ядра, который мониторил сетевой трафик браузера Mozilla Firefox.

\includeimage
    {ui-04}
    {f}
    {H}
    {1\textwidth}
    {Вывод в системный лог при загрузке модуля}
    
\includeimage
    {ui-05}
    {f}
    {H}
    {.8\textwidth}
    {Результат работы загружаемого модуля ядра на примере браузера Mozilla Firefox}

\section*{Вывод из исследовательской части}

В ходе выполнения исследовательской части было проведено тестирование реализованного загружаемого модуля ядра для мониторинга сетевого трафика процесса на примере трех программ.

{\centering \chapter*{ЗАКЛЮЧЕНИЕ}}
\addcontentsline{toc}{chapter}{ЗАКЛЮЧЕНИЕ}

В результате выполнения курсовой работы был реализован загружаемый модуль ядра, с помощью которого можно получить суммарный размер полученных и отправленных каким-либо процессом пакетов по сети.

Выполнены следующие задачи:
\begin{enumerate}
\item[1)] проведен обзор существующих средств для перехвата функций ядра Linux и выбран фреймворк ftrace;
\item[2)] спроектирован загружаемый модуль ядра --- определены необходимые структуры и действия, выполняемые программным обеспечением;
\item[3)] реализован загружаемый модуль ядра для мониторинга сетевого трафика процесса;
\item[4)] протестировано реализованное программное обеспечение.
\end{enumerate}

{\centering \printbibliography[title=СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ,heading=bibintoc]}

{\centering \chapter*{ПРИЛОЖЕНИЕ А}}
\addcontentsline{toc}{chapter}{ПРИЛОЖЕНИЕ А Руководство пользователя}
\begin{center}
\textbf{Руководство пользователя}
\end{center}

Для отслеживания сетевого трафика процесса с помощью реализованного в данной курсовой работе загружаемого модуля ядра необходимо:
\begin{enumerate}
\item[1)] с помощью утилиты make и файла Makefile собрать загружаемый модуль ядра;
\item[2)] загрузить модуль с помощью команды sudo insmod net\_traffic.ko fname=NAME, где NAME --- имя файла;
\item[3)] запустить файл с именем NAME;
\item[4)] после завершения отслеживаемого процесса, нужно посмотреть системный лог с помощью команды sudo dmesg;
\item[5)] с помощью команды sudo rmmod net\_traffic выгрузить модуль.
\end{enumerate}

В системном логе можно увидеть следующую информацию: название файла, идентификатор отслеживаемого процесса, суммарный объем отправленных и полученных процессом пакетов в байтах. 
Также в системном логе выводится размер каждого отправленного и принятого процессом пакета.

{\centering \chapter*{ПРИЛОЖЕНИЕ Б}}
\addcontentsline{toc}{chapter}{ПРИЛОЖЕНИЕ Б Исходный код загружаемого модуля ядра}
\begin{center}
\textbf{Исходный код загружаемого модуля ядра}
\end{center}

В листинге~\ref{lst:module.c} показан исходный код реализованного загружаемого модуля ядра для мониторинга сетевого трафика процесса.

\includelisting{module.c}{Исходный код реализованного загружаемого модуля ядра}

\end{document}
