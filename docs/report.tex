\documentclass{bmstu}

\usepackage{biblatex}
\usepackage{array}
\usepackage{amsmath}

\addbibresource{inc/biblio/sources.bib}

\begin{document}

\makecourseworktitle
    {Информатика и системы управления}
    {Программное обеспечение ЭВМ и информационные технологии}
    {Загружаемый модуль ядра для мониторинга сетевого трафика процесса}
    {В.~Марченко/ИУ7-73Б}
    {Н.~Ю.~Рязанова}
    {}

\setcounter{page}{3}

{\centering \chapter*{РЕФЕРАТ}}

Расчетно-пояснительная записка 43 с., 16 рис., 1 табл., 6 источн., 2 прил.

\noindent ЗАГРУЖАЕМЫЙ МОДУЛЬ ЯДРА, ОПЕРАЦИОННЫЕ СИСТЕМЫ, СЕТЕВОЙ ТРАФИК, СИСТЕМНЫЕ ВЫЗОВЫ, СОКЕТЫ, ФУНКЦИИ ЯДРА, FTRACE, LINUX

Объектом разработки является загружаемый модуль ядра для мониторинга сетевого трафика процесса.

Цель работы: реализация загружаемого модуля ядра, с помощью которого можно получить суммарный размер полученных и отправленных каким-либо процессом пакетов по сети.

В результате выполнения работы был реализован и протестирован загружаемый модуль ядра для мониторинга сетевого трафика процесса.

Область применения результатов --- мониторинг сетевого трафика процессов и расширение функционала реализованного загружаемого модуля ядра.

{\centering \maketableofcontents}

{\centering \chapter*{ПЕРЕЧЕНЬ СОКРАЩЕНИЙ И ОБОЗНАЧЕНИЙ}}

В настоящей расчетно-пояснительной записке к курсовой работе применяют следующие сокращения и обозначения:

\begin{table}[H]
\begin{tabular}{p{5cm}p{10.5cm}}
ОС & Операционная система
\tabularnewline
ПО & Программное обеспечение
\tabularnewline
ЗМЯ & Загружаемый модуль ядра
\tabularnewline
PID & Идентификатор процесса (от англ. process identifier)
\tabularnewline
\end{tabular}
\end{table}

{\centering \chapter*{ВВЕДЕНИЕ}}
\addcontentsline{toc}{chapter}{ВВЕДЕНИЕ}

Сетевой трафик --- объем информации, передаваемой через компьютерную сеть за определенный период времени. 
Количество трафика измеряется как в пакетах, так и в битах, байтах и их производных. 
Трафик подразделяется на:
\begin{enumerate}
\item[1)] исходящий (информация, поступающая во внешнюю сеть);
\item[2)] входящий (информация, поступающая из внешней сети);
\item[3)] внутренний (в пределах определенной сети, чаще всего локальной);
\item[4)] внешний (за пределами определенной сети).
\end{enumerate}

В настоящее время сетевой трафик является неотъемлемой частью повседневной жизни, и его отслеживание играет важную роль в различных сферах. Отслеживание сетевого трафика позволяет анализировать передаваемые данные, идентифицировать нарушения безопасности, оптимизировать сеть и повышать эффективность работы.

Существует множество программ для подсчета сетевого трафика. 
Например, TMeter, BWMeter, BitMeter II и GabNetStats --- это утилиты для операционных систем семейства Microsoft Windows. 
Для Linux доступны программы vnStat, Nload и slurm. 
На рисунке~\ref{img:vnstat} показан пример работы утилиты vnStat.
Вышеперечисленные программы позволяют получать информацию о скорости передачи данных в сети и об объеме передаваемых по сети пакетов. 
Существенный недостаток некоторых из этих инструментов --- они отслеживают сетевой трафик не для конкретного процесса, а для всей системы.

Для отслеживания сетевого трафика необходимо перехватывать функции ядра. 
Существует несколько способов это сделать:
\begin{enumerate}
\item[1)] модификация таблицы системных вызовов (данный способ устарел в новых версиях ядра);
\item[2)] использование утилиты strace;
\item[3)] использование системного вызова ptrace();
\item[4)] использование фреймворка ftrace.
\end{enumerate}

\includeimage
    {vnstat}
    {f}
    {H}
    {1\textwidth}
    {Пример работы утилиты vnStat}

\chapter{Аналитический раздел}

\section{Постановка задачи}

В соответствии с заданием на курсовую работу целью является реализация загружаемого модуля ядра, с помощью которого можно получить суммарный размер полученных и отправленных каким-либо процессом пакетов по сети.

Задачи курсовой работы:
\begin{enumerate}
\item[1)] провести сравнительный анализ существующих методов перехвата функций ядра Linux и выбрать наиболее подходящий для достижения поставленной цели;
\item[2)] разработать программное обеспечение для мониторинга сетевого трафика процесса;
\item[3)] реализовать ПО для мониторинга сетевого трафика процесса;
\item[4)] протестировать реализованное программное обеспечение.
\end{enumerate}

\section{Ограничения и требования к ПО}

Разрабатываемый загружаемый модуль ядра должен перехватывать функции, относящиеся к передачи пакетов по сети. 
Подсчет объема сетевого трафика должен вестись для конкретного процесса, поэтому перед загрузкой модуля ему на вход нужно передать имя программы.

Для хранения объема отправленных и полученных пакетов в байтах можно использовать переменную типа uint64\_t. 
Этот тип данных обеспечивает наибольший диапазон беззнаковых чисел в языке C. 
Таким образом, ограничение к разрабатываемому модулю: наибольший объем полученных и отправленных по сети пакетов --- 16384 пебибайт (18446744 терабайт).

\pagebreak
\section{Методы перехвата функций ядра Linux}

\subsection{strace}

В Linux есть несколько средств для перехвата функций ядра. 
Первое средство --- утилита strace.

strace --- это диагностическая и отладочная утилита, работающая в пространстве пользователя. 
Она используется для мониторинга и изменения взаимодействия между процессами и ядром Linux, включая системные вызовы, доставку сигналов и изменения состояния процесса. 
Данная утилита подходит для решения проблем с программами, исходный код которых недоступен, поскольку их не нужно перекомпилировать для отладки. 
Работа strace основана на системном вызове ptrace()~\cite{Strace}.

Достоинства strace --- утилиту можно запустить для трассировки уже работающий программы; можно фильтровать системные вызовы, которые необходимо отслеживать, по типу; а также можно собирать статистику (количество вызовов, время выполнения и ошибки)~\cite{Strace}.

В листинге~\ref{lst:strace.sh} показан пример работы утилиты strace.

\includelisting{strace.sh}{Пример работы утилиты strace}

\subsection{ptrace}

ptrace (от англ. process trace) --- системный вызов в некоторых UNIX-подобных системах (в том числе в Linux и FreeBSD), который позволяет трассировать или отлаживать выбранный процесс. 
Можно сказать, что ptrace() дает полный контроль над процессом: можно изменять ход выполнения программы, смотреть и изменять значения в памяти или состояния регистров. 
Никаких дополнительных прав нет --- возможные действия ограничены правами запущенного процесса. 
К тому же, при трассировке программы с setuid битом, этот самый бит не работает --- привилегии не повышаются~\cite{Ptrace}.

В листинге~\ref{lst:ptrace.h} показан прототип системного вызова ptrace().

\includelisting{ptrace.h}{Прототип системного вызова ptrace()}

Значения параметров системного вызова ptrace(): request --- это действие, которое необходимо осуществить, например PTRACE\_CONT, PTRACE\_PEEKTEXT, pid --- идентификатор трассируемого процесса, addr и data зависят от request~\cite{Ptrace}.

Начать трассировку можно двумя способами: для уже запущенного процесса (PTRACE\_ATTACH), либо запустить процесс самому с помощью PTRACE\_TRACEME. 
Для управления трассировкой можно использовать следующие аргументы~\cite{Ptrace}:
\begin{enumerate}
\item[1)] PTRACE\_SINGLESTEP --- пошаговое выполнение программы, управление будет передаваться после выполнения каждой инструкции (такая трассировка достаточно медленная);
\item[2)] PTRACE\_SYSCALL --- продолжить выполнение программы до входа или выхода из системного вызова;
\item[3)] PTRACE\_CONT --- продолжить выполнение программы.
\end{enumerate}

\subsection{ftrace}

ftrace --- это внутренний трассировщик, призванный помочь разработчикам и проектировщикам систем обнаружить, что происходит внутри ядра. 
Его можно использовать для отладки или анализа задержек и проблем с производительностью, возникающих за пределами пространства пользователя~\cite{Ftrace}.

Хотя ftrace обычно считается средством трассировки функций, на самом деле это совокупность нескольких различных утилит трассировки. 
Существует трассировка задержки для проверки того, что происходит между отключенными и включенными прерываниями, а также с момента пробуждения задачи до ее фактического планирования~\cite{Ftrace}.

Одним из наиболее распространенных применений ftrace является трассировка событий. 
По всему ядру есть сотни статических событий, которые можно включить через файловую систему tracefs, чтобы увидеть, что происходит в определенных частях ядра~\cite{Ftrace}.

Инфраструктура ftrace изначально была создана для прикрепления функций обратного вызова (callbacks) к началу функций с целью записи и отслеживания потока ядра. 
Но обратные вызовы в начале функции могут иметь и другие варианты использования. 
Либо для оперативного исправления ядра, либо для мониторинга безопасности~\cite{Ftrace}.

Чтобы зарегистрировать функции обратного вызова, нужно использовать структуру struct ftrace\_ops. 
Эта структура используется, чтобы сообщить ftrace, какую функцию следует вызывать в качестве обратного вызова~\cite{Ftrace}.

Необходимо заполнить только одно поле при регистрации struct ftrace\_ops --- func. 
Поля flags и private не являются обязательными~\cite{Ftrace}. 
В листинге~\ref{lst:ftrace_ops.c} показан пример заполнения полей структуры struct ftrace\_ops.

\includelisting{ftrace_ops.c}{Пример заполнения полей структуры struct ftrace\_ops}

Чтобы начать трассировку, нужно вызвать функцию register\_ftrace\_function(\&fops), а чтобы завершить --- unregister\_ftrace\_function(\&fops)~\cite{Ftrace}.

Структура struct ftrace\_ops и необходимые для трассировки функции определены в заголовочном файле <linux/ftrace.h>~\cite{Ftrace}.

\pagebreak
\section{Сравнительный анализ методов перехвата функций ядра}

В таблице~\ref{tabular:comparison} приведено сравнение рассмотренных методов перехвата функций ядра Linux.

\begin{table}[H]
\caption{Сравнение методов перехвата функций ядра}
\label{tabular:comparison}
\begin{tabular}{|p{3cm}|p{4cm}|p{4cm}|p{4cm}|}
\hline
\textbf{Метод} & \textbf{Возможность перехвата функций, вызванных конкретным процессом} & \textbf{Тип} & \textbf{Пространство}
\tabularnewline
\hline
strace & + & утилита & пользователя
\tabularnewline
\hline
ptrace() & + & системный вызов & пользователя
\tabularnewline
\hline
ftrace & + & фреймворк & ядра
\tabularnewline
\hline
\end{tabular}
\end{table}

Все рассмотренные методы обеспечивают возможность перехвата функций ядра для конкретного процесса, однако только ftrace работает в пространстве ядра, что и делает его подходящим средством для реализации загружаемого модуля.

\section{Аргументы командной строки для загружаемого модуля ядра}

Как и любая другая программа на языке C, загружаемый модуль ядра может принимать аргументы командной строки. 
Чтобы разрешить передачу аргументов в модуль, нужно объявить переменные, которые будут принимать значения аргументов командной строки, как глобальные, а затем использовать макрос module\_param(), который определен в <linux/moduleparam.h>. 
Во время выполнения insmod проинициализирует переменные значениями аргументов командной строки. 
Объявления переменных и макросы размещаются в начале модуля. 
Макрос module\_param() принимает 3 аргумента: имя переменной, ее тип и права доступа к соответствующему файлу в sysfs. 
Если необходимо использовать массивы целых чисел или строк, нужно использовать макросы module\_param\_array() и module\_param\_string()~\cite{ArgvLkm}.

\pagebreak
В листинге~\ref{lst:argv.c} показан пример объявления глобальных переменных, которые могут быть проинициализированы с помощью аргументов командной строки.

\includelisting{argv.c}{Пример объявления глобальных переменных для использования аргументов командной строки}

\section{Определение функций ядра для перехвата}

Прототипы функций ядра, которые могут быть перехвачены с помощью ftrace, находятся в заголовочном файле <linux/syscalls.h>~\cite{Syscalls}.

Чтобы определить функции ядра, которые выполняются при вызове конкретных системных вызовов, можно написать программу, вызывающую соответствующие системные вызовы, и воспользоваться утилитой strace.

\subsection{Определение целевого процесса}

Для того, чтобы мониторить сетевой трафик конкретного процесса, после передачи имени программы на вход загружаемому модулю ядра, нужно запустить эту программу. 
При этом необходимо перехватить функцию sys\_execve(), которая вызывается при запуске программы. 
Затем с помощью функции copy\_from\_user() модуль сможет получить имя запущенной программы и сравнить с тем, которое было передано в качестве аргумента командной строки. 
Вторая функция ядра --- sys\_exit\_group() --- будет вызвана при завершении отслеживаемого процесса. 
Перехватив эту функцию, загружаемый модуль ядра запишет в системный лог статистику.

\subsection{Определение размера пакета}

Также нужно перехватывать функции ядра, которые вызываются в системных вызовах, связанных с передачей пакетов по сети. 
Это следующие функции ядра: sys\_send(), sys\_sendto(), sys\_sendmsg(), sys\_recv(), sys\_recvfrom() и sys\_recvmsg().

В листинге~\ref{lst:syscalls.h} показаны прототипы перечисленных функций ядра~\cite{Syscalls}.

\includelisting{syscalls.h}{Прототипы функций ядра, которые нужно перехватывать для мониторинга сетевого трафика процесса}

\section*{Выводы из аналитического раздела}

В результате проведения сравнительного анализа методов перехвата функций ядра Linux был выбран фреймворк ftrace. 
Для определения процесса, от имени которого выполняются функции ядра, необходимо воспользоваться механизмом передачи аргументов командной строки в загружаемый модуль ядра и перехватить функцию sys\_execve(). 
Определены прототипы функций ядра для перехвата.

\chapter{Конструкторский раздел}

\section{Последовательность выполняемых ПО действий}

На рисунках~\ref{img:idef0-a0}--\ref{img:idef0-a1} показана последовательность выполняемых программным обеспечением действий в виде IDEF0-диаграмм нулевого и первого уровней.

\includeimage
    {idef0-a0}
    {f}
    {H}
    {.8\textwidth}
    {IDEF0-диаграмма нулевого уровня}
    
\includeimage
    {idef0-a1}
    {f}
    {H}
    {1\textwidth}
    {IDEF0-диаграмма первого уровня}

На вход загружаемому модулю ядра поступает имя файла в виде аргумента командной строки. 
Далее происходит проверка этого аргумента. 
Если ошибка не возникла, регистрируются перехватчики функций ядра и модуль загружается.

За счет перехвата функции sys\_execve() загружаемый модуль ядра получает PID целевого процесса. 
Перехватывая функции, связанные с передачей пакетов по сети, модуль считает размер отправленных и полученных процессом пакетов. 
За счет перехвата sys\_exit\_group() загружаемый модуль ядра выводит в системный лог статистику при завершении отслеживаемого процесса. 
Затем модуль выгружается.

\section{Алгоритм получения аргументов командной строки в режиме ядра}

На рисунке~\ref{img:argv} показана схема алгоритма получения аргументов командной строки в режиме ядра. 
Сначала проверяется, было ли указано имя файла в качестве аргумента командной строки. 
Затем, если проверка прошла успешно, регистрируются перехватчики функций ядра, и модуль загружается.

\includeimage
    {argv}
    {f}
    {H}
    {.65\textwidth}
    {Схема алгоритма получения аргументов командной строки в режиме ядра}

\pagebreak
\section{Алгоритм определения целевого процесса}

На рисунке~\ref{img:execve} показана схема алгоритма определения целевого процесса. 
Перед выполнением sys\_execve() проверяется, проинициализирован ли идентификатор целевого процесса. 
Если нет, имя файла копируется из пространства пользователя в пространство ядра. 
Затем происходит сравнение с именем, полученным в качестве аргумента командной строки. 
При успешном сравнении идентификатор целевого процесса инициализируется полученным с помощью макроса current значением процесса, от имени которого выполняется sys\_execve().

\includeimage
    {execve}
    {f}
    {H}
    {.75\textwidth}
    {Схема алгоритма определения целевого процесса}

\pagebreak
\section{Алгоритм получения размера пакета}

На рисунке~\ref{img:hook-send} показана схема алгоритма получения размера отправленного пакета на примере функции ядра sys\_send().

\includeimage
    {hook-send}
    {f}
    {H}
    {.75\textwidth}
    {Схема алгоритма получения размера пакета}

\pagebreak
\section{Структура ПО}

На рисунке~\ref{img:software-struct} показана структура разрабатываемого программного обеспечения для мониторинга сетевого трафика процесса.

\includeimage
    {software-struct}
    {f}
    {H}
    {1\textwidth}
    {Структура ПО} 

\chapter{Технологический раздел}

\section{Выбор языка и среды программирования}

Для реализации программного обеспечения был выбран язык программирования C, так как на нем написано ядро Linux, и он используется для написания загружаемых модулей ядра.

Для написания кода был выбран текстовый редактор Sublime Text 3, т.~к. он обладает следующими преимуществами~\cite{SublimeText}:
\begin{enumerate}
\item[1)] кроссплатформенность (доступность на Linux Ubuntu);
\item[2)] подсветка синтаксиса (в частности, для языка C);
\item[3)] настраиваемый интерфейс;
\item[4)] множественное выделение (например, переменных);
\item[5)] автоматическое заполнение.
\end{enumerate}

\section{Используемые структуры}

Для реализации загружаемого модуля ядра были разработаны две структуры:

--- struct hook (листинг~\ref{lst:hook.c}). 
Поле name содержит название функции ядра (например, sys\_send). 
Поле function --- указатель на функцию, которую нужно вызвать вместо исходной. 
Поле original указывает на исходную функцию ядра. 
Поле address --- адрес исходной функции ядра. 
А поле ops --- экземпляр структуры struct ftrace\_ops.

\includelisting{hook.c}{Структура struct hook}

--- struct net\_traffic (листинг~\ref{lst:net_traffic.c}). 
Поле pid содержит идентификатор отслеживаемого процесса. 
Изначально значение этого поля равно -1. 
После того, как нужная программа будет запущена, поле pid проинициализируется идентификатором отслеживаемого процесса. 
Поля bytes\_received и bytes\_sent хранят объем соответственно входящих и исходящих пакетов в байтах.

\includelisting{net_traffic.c}{Структура struct net\_traffic}

\section{Реализация алгоритма получения аргументов командной строки в режиме ядра}

В листинге~\ref{lst:init-module.c} показана реализация алгоритма получения аргументов командной строки в режиме ядра.

\includelisting{init-module.c}{Реализация алгоритма получения аргументов командной строки в режиме ядра}

\section{Реализация алгоритма определения целевого процесса}

В листинге~\ref{lst:sys-execve.c} показана реализация алгоритма поиска процесса, чей сетевой трафик должен отслеживать загружаемый модуль ядра.

\includelisting{sys-execve.c}{Реализация алгоритма определения целевого процесса}

\section{Реализация алгоритма получения размера пакета}

В листинге~\ref{lst:sys-send.c} показана реализация алгоритма получения размера отправленного пакета на примере перехвата функции ядра sys\_send().

\includelisting{sys-send.c}{Реализация алгоритма получения размера пакета}

\section{Реализация алгоритма регистрации перехватчика}

В листинге~\ref{lst:install-hook.c} показана реализация алгоритма регистрации перехватчика.

\includelisting{install-hook.c}{Реализация алгоритма регистрации перехватчика}

\section{Makefile для сборки загружаемого модуля ядра}

В листинге~\ref{lst:makefile} показан Makefile для сборки загружаемого модуля ядра.

\includelisting{makefile}{Makefile для сборки загружаемого модуля ядра}

\chapter{Исследовательский раздел}

\section{Технические характеристики устройства}

Технические характеристики устройства, на котором было проведено тестирование реализованного программного обеспечения:
\begin{enumerate}
\item[1)]
операционная система Ubuntu 22.04.3 LTS;
\item[2)]
оперативная память 4 ГБ;
\item[3)]
процессор Intel\textregistered ~Core\texttrademark ~i5-4790K @ 4.00 ГГц;
\item[4)] версия ядра Linux 6.2.0.
\end{enumerate}

\section{Тестирование программного обеспечения}

Для тестирования реализованного программного обеспечения были написаны две тестовые программы, имеющие архитектуру <<клиент---сервер>>. 
В первой программе для взаимодействия используются системные вызовы recv() и send(), а во второй --- recvfrom() и sendto(). 
В обеих программах клиенты сообщают серверу свой PID. 
То же делает сервер --- сообщает клиентам свой идентификатор. 
И сервер, и клиенты выводят длину полученного сообщения. 
Таким образом можно проверить суммарный размер пакетов, который вывел в системный лог реализованный загружаемый модуль ядра. 
Также реализованное ПО было протестировано с помощью браузера Mozilla Firefox.

На рисунке~\ref{img:ui-01} показан результат работы загружаемого модуля ядра при отсутствии аргумента командной строки.

\includeimage
    {ui-01}
    {f}
    {H}
    {1\textwidth}
    {Результат работы загружаемого модуля ядра при отсутствии аргумента командной строки}
 
На рисунке~\ref{img:ui-02} показан результат работы загружаемого модуля ядра, который мониторил сетевой трафик процесса-сервера, использующего системные вызовы recv() и send(). 
На рисунках~\ref{img:server-02}--\ref{img:client-02} показаны размеры пакетов, которые соответственно получал и отправлял отслеживаемый процесс.

\includeimage
    {server-02}
    {f}
    {H}
    {1\textwidth}
    {Размеры пакетов, которые получал отслеживаемый процесс}
    
\includeimage
    {client-02}
    {f}
    {H}
    {1\textwidth}
    {Размеры пакетов, которые отправлял отслеживаемый процесс}

\includeimage
    {ui-02}
    {f}
    {H}
    {1\textwidth}
    {Результат работы загружаемого модуля ядра на примере системных вызовов recv() и send()}
    
На рисунке~\ref{img:ui-03} показан результат работы загружаемого модуля ядра, который мониторил сетевой трафик процесса-сервера, использующего системные вызовы recvfrom() и sendto(). 
На рисунках~\ref{img:server-03}--\ref{img:client-03} показаны размеры пакетов, которые соответственно получал и отправлял отслеживаемый процесс.

\includeimage
    {server-03}
    {f}
    {H}
    {1\textwidth}
    {Размеры пакетов, которые получал отслеживаемый процесс}
    
\includeimage
    {client-03}
    {f}
    {H}
    {1\textwidth}
    {Размеры пакетов, которые отправлял отслеживаемый процесс}

\includeimage
    {ui-03}
    {f}
    {H}
    {1\textwidth}
    {Результат работы загружаемого модуля ядра на примере системных вызовов recvfrom() и sendto()}
    
На рисунках~\ref{img:ui-04}--\ref{img:ui-05} показан результат работы загружаемого модуля ядра, который мониторил сетевой трафик браузера Mozilla Firefox.

\includeimage
    {ui-04}
    {f}
    {H}
    {1\textwidth}
    {Вывод в системный лог при загрузке модуля}
    
\includeimage
    {ui-05}
    {f}
    {H}
    {.8\textwidth}
    {Результат работы загружаемого модуля ядра на примере браузера Mozilla Firefox}

\section*{Выводы из исследовательского раздела}

Для тестирования реализованного ПО были написаны две программы, имеющие архитектуру <<клиент---сервер>>, и взаимодействующие с помощью системных вызовов send() и recv() в первом случае и sendto() и recvfrom() во втором. 
Также загружаемый модуль ядра был протестирован с помощью браузера Mozilla Firefox. 
Все тесты пройдены успешно.

{\centering \chapter*{ЗАКЛЮЧЕНИЕ}}
\addcontentsline{toc}{chapter}{ЗАКЛЮЧЕНИЕ}

В результате выполнения курсовой работы был реализован загружаемый модуль ядра для мониторинга сетевого трафика процесса. 
Реализованное ПО принимает на вход имя файла в качестве аргумента командной строки, перехватывает функцию sys\_execve(), определяет целевой процесс и мониторит его сетевой трафик.

Выполнены следующие задачи:
\begin{enumerate}
\item[1)] проведен сравнительный анализ существующих методов перехвата функций ядра Linux и выбран наиболее подходящий для достижения поставленной цели --- фреймворк ftrace;
\item[2)] разработано программное обеспечение для мониторинга сетевого трафика процесса;
\item[3)] реализовано ПО для мониторинга сетевого трафика процесса;
\item[4)] протестировано реализованное программное обеспечение.
\end{enumerate}

{\centering \printbibliography[title=СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ,heading=bibintoc]}

{\centering \chapter*{ПРИЛОЖЕНИЕ А}}
\addcontentsline{toc}{chapter}{ПРИЛОЖЕНИЕ А Руководство пользователя}
\begin{center}
\textbf{Руководство пользователя}
\end{center}

Для мониторинга сетевого трафика процесса с помощью реализованного загружаемого модуля ядра необходимо:
\begin{enumerate}
\item[1)] с помощью утилиты make и файла Makefile собрать загружаемый модуль ядра;
\item[2)] загрузить модуль с помощью команды sudo insmod net\_traffic.ko fname=NAME, где NAME --- имя файла;
\item[3)] запустить файл с именем NAME;
\item[4)] после завершения отслеживаемого процесса, нужно посмотреть системный лог с помощью команды sudo dmesg;
\item[5)] с помощью команды sudo rmmod net\_traffic выгрузить модуль.
\end{enumerate}

В системном логе можно увидеть следующую информацию: имя файла, идентификатор отслеживаемого процесса, суммарный объем отправленных и полученных процессом пакетов в байтах. 
Также в системный лог выводится размер каждого отправленного и принятого процессом пакета.

{\centering \chapter*{ПРИЛОЖЕНИЕ Б}}
\addcontentsline{toc}{chapter}{ПРИЛОЖЕНИЕ Б Исходный код загружаемого модуля ядра}
\begin{center}
\textbf{Исходный код загружаемого модуля ядра}
\end{center}

В листинге~\ref{lst:module.c} показан исходный код реализованного загружаемого модуля ядра для мониторинга сетевого трафика процесса.

\includelisting{module.c}{Исходный код реализованного загружаемого модуля ядра}

\end{document}
